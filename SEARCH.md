之前几段工作经历都与搜索有关，来阿里做了两年多的业务和数据了。最近正好有业务继续想用搜索，就对搜索引擎做一个原理性的分享，包括搜索的一系列原理、数据结构、算法。

# 搜索是什么？

这里有个概念需要提一下。信息检索 (Information Retrieval 简称 IR) 和 搜索 (Search) 是有区别的，信息检索是一门学科，研究信息的获取、表示、存储、组织和访问，而搜索只是信息检索的一个分支，其他的如问答系统、信息抽取、信息过滤也可以是信息检索。

本文要讲的搜索，是通常意义上的全文搜索比如 Google、Baidu，天猫搜索商品、口碑搜索美食、飞猪搜索酒店等。

# 为什么需要搜索？

看一个实际的例子：如何从一个亿级数据的商品表里，寻找 “帽子” 商品。

## SQL Like

    select * from item where name like '%帽子%'

如上，第一个实现是用 like，这无法使用上索引，查询速度会非常的慢。

## 搜索

此处有一张图

搜索会首先 build 一个倒排索引，通过分词、构建词典、构建倒排表、压缩等一系列操作构建一个索引，查询通过词典快速拿到倒排表的结果。这既能解决全文检索的问题，又解决了SQL速度慢的问题。

# 搜索是怎么做的？

## 分词

分词就是对一段文本，通过规则或者算法分出多个词，每个词作为搜索的最细粒度一个个单字或者单词。只有分词后有这个词，搜索才能搜到，分词的正确性非常重要。分词粒度太大，搜索召回率就会偏低，分词粒度太小，准确率就会降低。如何恰到好处的分词，是搜索引擎需要做的第一步。

### 正确性&粒度

* 分词正确性
 * “他说的确实在理”，这句话如何分词？
  * “他-说-的确-实在-理”  [错误语义]
  * “他-说-的-确实-在理”  [正确语义]
* 分词的粒度
 * “中华人民共和国宪法”，这句话如何分词？
 * “中华人民共和国-宪法”，[搜索 中华、共和国 无结果]
 * “中华-人民-共和国-宪法”，[搜索 共和 无结果]
 * “中-华-人-民-共-和-国-宪-法”，[搜索其中任意字都有结果]

分词的粒度并不是越小越好，他会降低准确率，比如搜索 “中秋” 也会出现上条结果，而且粒度越小，索引词典越大，搜索效率也会下降，后面会细说。

如何准确的把控分词，涉及到 NLP 的内容啦，这里就不展开了。

### 停用词

很多语句中的词都是没有意义的，比如 “的”，“在” 等副词、谓词，英文中的 “a”，“an”，“the”，在搜索是无任何意义的，所以在分词构建索引时都会去除，降低不不要的索引空间，叫停用词 (StopWord)。

通常可以通过文档集频率和维护停用词表的方式来判断停用词。

### 词项处理

词项处理，是指在原本的词项上在做一些额外的处理，比如归一化、词形归并、词干还原等操作，以提高搜索的效果。并不是所有的需求和业务都要词项处理，需要根据场景来判断。

#### 1. 归一化

* USA - U.S.A.  [缩写]
* 7月30日 - 7/30  [中英文]
* color - colour  [通假词]
* 开心 - 高兴  [同义词扩展范畴]

这样查询 U.S.A. 也能得到 USA 的结果，同义词可以算作归一化处理，不过同义词还可以有其他的处理方式。

#### 2. 词形归并（Lemmatization）

针对英语同一个词有不同的形态，可以做词形归并成一个，如：

• am, are, is -> be
• car, cars, car's, cars' -> car
• the boy's cars are different colors -> the boy car be different color

#### 3. 词干还原（Stemming）

通常指的就粗略的去除单词两端词缀的启发式过程

• automate(s), automatic, automation -> automat.
* 高高兴兴 -> 高兴  [中文重叠词还原]
* 明明白白 -> 明白

英文的常见词干还原算法，Porter算法。

## 倒排索引

要了解倒排索引，先看一下什么是正排索引。比如有下面两句话：

* id1, “搜索引擎提供检索服务”
* id2, “搜索引擎是信息检索系统”

### 正排索引

正排索引就是 MySQL 里的 B+ Tree，索引的结果是：

* “搜索引擎是信息检索系统” -> id2
* “搜索引擎提供检索服务” -> id1

表示对完整内容按字典序排序，得到一个有序的列表，以加快检索的速度。

### 倒排索引

1. 第一步 分词

* “搜索引擎-提供-检索-服务” -> id1
* “搜索引擎-是-信息-检索-系统” -> id2

2. 第二步 将分词项构建一个词典

* 搜索引擎
* 提供
* 检索
* 服务
* 是
* 信息
* 系统

3. 第三步 构建倒排链

* 搜索引擎 -> id1, id2
* 提供 -> id1
* 检索 -> id1, id2
* 服务 -> id1
* 是 -> id2
* 信息 -> id2
* 系统 -> id2

由此，一个倒排索引就完成了，搜索 “检索” 时，得到 id1, id2，说明这两条数据都有，搜索 “服务” 只有 id1 存在。但如果搜索 “检索系统”，此时会先建搜索词按照与构建同一种策略分词，得到 “检索-系统”，两个词项，分别搜索 检索 -> id1, id2 和 系统 -> id2，然后对其做一个交集，得到 id2。同理，通过求并集可以支持更负责的查询。

倒排索引到此也就讲清楚了吧。

## 

短语查询（ Phrase Query ）
第一种方法：二元词索引（ Biword
indexes ）
第二种方法：位置信息索引（Positional
indexes）

邻近查询（Proximity queries）

• Employ me/3 place,表示从左边或右边相距在k个
词之类

位置信息索引的讨论
• 采用位置索引会大大增加倒排记录表的存储空间，
即使采用后面讨论的压缩方法也无济于事。
• 由于用户期望能够进行短语查询和邻近查询，所以
还是得采取这种索引方式。

## 空间索引

在点评口碑上，经常有类似的场景，搜索 “1公里以内的美食”，那么这个1公里怎么实现呢？

在数据库中可以通过暴力计算、矩形过滤、以及B树对经度和维度建索引，但这性能仍然很慢(可参考 [为什么需要空间索引](https://www.cnblogs.com/LBSer/p/3392491.html) )。搜索里用了一个很巧妙的方法，Geo Hash。

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/14dd678172ea1b6bbb21d07d4bb8dbdd.png)

如上图，表示根据 GeoHash 对北京几个区域生成的字符串，有几个特点：

* 一个字符串，代表一个矩形区域
* 字符串越长，表示的范围越精确 (长度为8时精度在19米左右，而当编码长度为9时精度在2米左右)
* 字符串相似的，表示距离相近 （这就可以利用字符串的前缀匹配来查询附近的POI信息)

### Geo Hash 如何编码？

地球上任何一个位置都可以用经纬度表示，经度的区间是 [-90, 90]，维度的区间 [-180, 180]。比如天安门的坐标是 39.908,116.397，整体编码过程如下：

#### 一、对经度 39.908 的编码如下：

1. 将经度划分2个区间，左区间 [-90, 0) 用 0 表示，右区间 [0, 90] 用 1 表示， 39.908 处在右区间，故第一位编码是 1；
2. 在将 [0, 90] 划分2个区间，左区间 [0, 45) 用 0 表示，右区间 [45, 90] 用 1 表示，39.908处在左区间， 故第二位编码是 0；
3. 同1、2的计算步骤，39.908 的最后10位编码是 “10111 00011”

#### 二、对纬度 116.397 的编码如下：

1. 将纬度划分2个区间，左区间 [-180, 0) 用 0 表示，右区间 [0, 180] 用 1 表示，116.397处在右区间， 故第一位编码是 1；
2. 在将 [0, 180] 划分2个区间，左区间 [0, 90) 用 0 表示，右区间 [90, 180] 用 1 表示，116.397处在右区间，故第二位编码是 1；
3. 同1、2的计算步骤，116.397 的最后6位编码是 “11010 01001”

#### 三、合并组码

1. 将偶数位放经度，奇数位放纬度，把2串编码组合生成新串：“11100 11101 00100 00111”；
2. 通过 Base32 编码，每5个二进制编码一个数，“28 29 4 G”
3. 根据 Base32 表，得到 Geo Hash 为：“WX4G”

即最后天安门的4位 Geo Hash 为 “WX4G”，如果需要经度更准确，在对应的经纬度编码粒度再往下追溯即可。

附：Base32 编码图
![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/69704e3b04fa551122e30990d38097d4.png)

### Geo Hash 如何用于地理搜索？

举个例子，搜索天安门附近 200 米的景点，如下是天安门附近的Geo编码

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/62c45d1dbad831ef4e92fcb4a6d7efbf.png)

搜索过程如下：

1. 首先确定天安门的Geo Hash为 WX4G0B，（6位区域码约 0.34平分千米，约为长宽600米区域)
2. 而6位编码表示 600 米，半径 300 米 > 要求的 200 米，搜索所有编码为 WX4G0B 的景点即可
3. 但是由于天安门处于 WX4G0B 的边缘位置，并不一定处在正中心。这就需要将 WX4G0B 附近的8个区域同时纳入搜索，故搜索 WX4G0B、WX4G09、WX4G0C 一共9个编码的景点
4. 第3步已经将范围缩小到很小的一个区间，但是得到的景点距离并不是准确的，需要在通过距离计算过滤出小于 200 米的景点，得到最终结果。

由上面步骤可以看出，Geo Hash 将原本大量的距离计算，变成一个字符串检索缩小范围后，再进行小范围的距离计算，及快速又准确的进行距离搜索。

### Geo Hash 依据的数学原理

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/ef3c2dfec575f690e41ff7523a8311bf.png)

如图所示，我们将二进制编码的结果填写到空间中，当将空间划分为四块时候，编码的顺序分别是左下角00，左上角01，右下脚10，右上角11，也就是类似于Z的曲线。当我们递归的将各个块分解成更小的子块时，编码的顺序是自相似的（分形），每一个子快也形成Z曲线，这种类型的曲线被称为Peano空间填充曲线。

这种类型的空间填充曲线的优点是将二维空间转换成一维曲线（事实上是分形维），对大部分而言，编码相似的距离也相近， 但Peano空间填充曲线最大的缺点就是突变性，有些编码相邻但距离却相差很远，比如0111与1000，编码是相邻的，但距离相差很大。 

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/f5cf54104ab84e83ca8b7a45b793a9cd.png)

除Peano空间填充曲线外，还有很多空间填充曲线，如图所示，其中效果公认较好是Hilbert空间填充曲线，相较于Peano曲线而言，Hilbert曲线没有较大的突变。为什么GeoHash不选择Hilbert空间填充曲线呢？可能是Peano曲线思路以及计算上比较简单吧，事实上，Peano曲线就是一种四叉树线性编码方式。 

## 数值索引

## 数据结构

### LSM思想

### 倒排链

### Doc Values

### FST

### SkipList

在什么位置设置跳表指针？
• 策略：
• 设置较多的指针较短的步长更多的跳跃机会
• 更多的指针比较次数和更多的存储空间
• 设置较少的指针较少的指针比较次数，但是需要设置
较长的步长较少的连续跳跃

如果倒排表的长度是L，那么在每个 处均匀放置跳表指针

### GEO哈希

### BKD Tree

### TF-IDF

### BM25

### BitMap 过滤

### 压缩算法

无损压缩：压缩之后所有原始信息都被保留。
• 在IR系统中常采用无损压缩
• 有损压缩：丢掉一些信息

#### dictionary 压缩：基于词典、跳跃、前缀压缩、二分查找 

#### postling 压缩：差值压缩、可变字节压缩、p4del、simle9、simple16、跳跃表

• 统计信息(对RCV1语料库)
• 词典和倒排记录表将会有多大？
• Heaps定律：词项数目的估计
• Zipf定律：对词项的分布建模

词典压缩
• 将词典看成单一字符串的压缩方法
• 按块存储/前端编码
倒排记录表压缩
• 可变长字节码
• 一元编码/ γ 编码

词典压缩
1 定长方法存储词项浪费空间

2压缩词项列表：将词典看成单一字符串
（ Dictionary-as-a-String ）
• 将词典存储为一个长字符串：
• 指向下一词项的指针同时也标识着当前词项的结束
• 期望节省60%的词典空间

![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/41633ac6529e37d8bf175d5f0e7e3b91.png)

3.按块存储（Blocking）
• 我们为每第k个词项字符串存储一个指针
• 下面的例子：k=4
• 需要存储词项长度(额外1字节)

4.前端编码（Front coding）
8automata8automate9automatic10automation

倒排表压缩
1. GAP -> 可变字节码(Variable Byte )
2. 可变长编码
3. 一元编码(Unary code) 
数n用n个1后面加个0表示 • 3的一元编码为1110

4. Y编码
![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/c338f5e25e16f0c9387b4ed44d0eed15.png)
更高的压缩率，但是解压的消耗会更高

5.RCV压缩


###

# 查找

## 模糊查找

## 范围查找

## 空间查找

## 坡度查询

## 分组实现

# 排序算法

非精确top K检索
* 策略一：索引去除(Index elimination)
• 策略二：胜者表
• 策略三：静态得分
• 策略四：影响度排序
• 策略五：簇剪枝方法——预处理
• 策略六：参数化索引以及域索引
• 策略七：层次索引


## 

## 自定义排序

